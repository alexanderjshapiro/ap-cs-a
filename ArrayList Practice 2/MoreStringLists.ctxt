#BlueJ class context
comment0.target=MoreStringLists
comment0.text=\n\ In\ this\ project\ you\ will\ gain\ more\ practice\ using\ the\ ArrayList\ class.\n\ \n\ NOTE\ 1\:\n\ \ Watch\ the\ types\ called\ for\ in\ each\ class\ carefully.\n\ \ Some\ use\ arrays\ and\ some\ use\ lists\ as\ parameters\ but\ NONE\ return\ an\n\ \ array.\n\ \ \n\ \ Just\ because\ a\ method\ takes\ an\ array\ as\ a\ parameter\ doesn't\ mean\ it\n\ \ that\ it\ can't\ return\ a\ List\!\n\ \n\ NOTE\ 2\:\n\ \ A\ check\ the\ pre-conditions\ carefully.\ If\ a\ method\ says\ a\ parameter\n\ \ is\ unchanged\ then\ you\ must\ not\ modify\ the\ array\ or\ list\ specified\n\ \ in\ your\ method\!\n\ \n\ @author\ (Alexander\ Shapiro)\ \n\ @version\ Unit\ 6\n
comment1.params=
comment1.target=java.lang.String\ yourName()
comment1.text=\n\ Simply\ return\ your\ name\ as\ a\ String,\ last\ name\ then\ first\ name,\ separated\ by\ a\ comma\n\n\ @return\ your\ name\ as\ a\ String\n
comment2.params=csv
comment2.target=java.util.List\ csvList(java.lang.String)
comment2.text=\n\ Given\ a\ string,\ create\ a\ list\ with\ each\ element\ split\ at\ the\ comma\ in\n\ the\ same\ relative\ order.\ \n\ \n\ For\ example\:\n\ \ csv\ \=\ "up,down,left,right,top,bottom"\n\ \ \n\ would\ return\:\n\ \ ["up","down","left","right","top","bottom"]\n\ \n\ Precondition\:\ \ \ \ csv\ is\ not\ null\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ csv.length()\ >\ 0\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ at\ least\ one\ non-comma\ character\ appears\ before\ and\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ after\ each\ comma\n\ @param\ \ \ csv\ a\ string\ of\ comma\ separated\ values\n\ @return\ \ a\ list\ of\ each\ comma\ separated\ value\n
comment3.params=names\ name
comment3.target=boolean\ isUnique(java.util.List,\ java.lang.String)
comment3.text=\n\ Given\ a\ list\ of\ names,\ return\ true\ if\ the\ parameter\ name\ does\ NOT\ already.\n\ appear\ in\ the\ list.\n\ \n\ Precondition\:\ \ \ \ names\ is\ not\ null\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ names.size\ >\ 0\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ name\ is\ not\ null\n\ Postcondition\:\ \ \ names\ is\ unchanged\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \n\ @param\ \ \ names\ \ \ a\ list\ of\ Strings\ that\ are\ names\n\ @param\ \ \ name\ \ \ \ the\ name\ that\ may\ be\ in\ the\ list\ \ \ \ \n\ @return\ \ true\ if\ name\ is\ not\ found\ in\ names\ and\ false\ if\ it\ is\ found\n
comment4.params=names
comment4.target=java.util.List\ reduce(java.lang.String[])
comment4.text=\n\ Given\ an\ array\ of\ names\ that\ may\ contain\ duplicates,\ return\ a\ list\ with\ no\ duplicates.\n\ The\ names\ should\ be\ in\ the\ same\ relative\ order\ as\ found\ in\ the\ orginal\ array.\n\ \n\ For\ example\:\n\ \ {"Aaron",\ "Ken",\ "Gena",\ "Aaron",\ "Michael"}\n\ would\ be\ reduced\ to\:\n\ \ ["Aaron",\ "Ken",\ "Gena",\ "Michael"]\n\ \n\ Precondition\:\ \ \ \ names\ is\ not\ null\n\ Postcondition\:\ \ \ names\ is\ unchanged\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \n\ @param\ \ \ names\ an\ array\ of\ names\ that\ may\ contain\ duplicates\n\ @return\ \ a\ list\ of\ names\ in\ the\ same\ relative\ order\ but\ with\ no\ duplicates\n
comment5.params=names1\ names2
comment5.target=java.util.List\ mergeDups(java.util.List,\ java.util.List)
comment5.text=\n\ Given\ two\ Lists\ of\ Strings\ return\ a\ new\ list\ that\ contains\ names\ that\ appear\ in\ both\ of\n\ the\ original\ lists.\ \ \n\ In\ other\ words,\ follow\ these\ guidelines\:\n\ Add\ each\ name\ from\ the\ first\ list\ to\ your\ new\ list\ only\ if\ it\n\ found\ in\ the\ second\ list.\ Add\ strings\ to\ the\ new\ list\ in\ order\n\ the\ order\ they\ are\ found\ in\ the\ first\ list\ (names1).\n\ \n\ For\ example\:\n\ \ names1\ \=\ ["Aaron",\ "Ken",\ "Gena",\ "Michael"]\n\ \ names2\ \=\ ["David",\ "Ken",\ "Aaron",\ "Jason"]\n\ \ \n\ would\ be\ merged\ into\:\n\ \ ["Aaron",\ "Ken"]\n\ \ \n\ because\ "Aaron"\ is\ the\ first\ name\ in\ the\ first\ list\ that\ is\ also\ found\n\ in\ the\ second\ list\ it\ is\ first\ in\ the\ resulting\ list\!\n\ \n\ Precondition\:\ \ \ \ names1\ and\ names2\ are\ not\ null\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ no\ elements\ are\ repeated\ more\ than\ once\ in\ names1\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ no\ elements\ are\ repeated\ more\ than\ once\ in\ names2\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \n\ Postcondition\:\ \ \ names1\ and\ names2\ are\ unchanged\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \n\ @param\ \ \ names1\ an\ a\ list\ of\ names\ (no\ duplicates)\n\ @param\ \ \ names2\ anotbher\ list\ of\ names\ (no\ duplicates)\n\ @return\ \ the\ names\ that\ appear\ in\ both\ names1\ and\ names2\ in\ the\ relative\n\ \ \ \ \ \ \ \ \ \ order\ found\ in\ names1\n
comment6.params=letters
comment6.target=java.util.List\ alphaOrder(java.lang.String)
comment6.text=\n\ Given\ a\ String\ of\ all\ capital\ letters,\ return\ a\ list\ containing\ each\n\ letter\ found\ in\ the\ string\ only\ once.\n\ The\ list\ should\ be\ in\ alphabetical\ order.\ \n\n\ HINT\:\ \ \ \ You\ can\ add\ elements\ to\ a\ list\ at\ any\ index\ so\ keep\ your\ list\n\ \ \ \ \ \ \ \ \ \ in\ alphabetical\ order\ as\ you\ make\ it\!\n\ \n\ For\ example\:\n\ \ letters\ \=\ "AARON"\n\ \ \n\ would\ return\:\n\ \ ["A",\ "N",\ "O",\ "R"]\n\ \ \ \ \ \ \n\ even\ though\ the\ "A"\ is\ found\ twice\ it\ is\ in\ the\ list\ only\ once\ and\ the\n\ remaining\ letters\ are\ in\ alphabetical\ order\!\n\ \n\ Precondition\:\ \ \ \ letters\ is\ not\ null\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ letters.length()\ >\ 0\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ all\ characters\ in\ letters\ are\ captialized\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \n\ @param\ \ \ letters\ a\ string\ containing\ capital\ letters\ (may\ contain\ duplicates)\n\ @return\ \ each\ letter,\ once,\ found\ in\ letters\ arranged\ in\ alphabetical\ order\n
numComments=7
